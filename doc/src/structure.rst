Структура кода
==============

Далее описана общая структуру кодовой базы xpic, включая то, как работает программа, организацию компонентов, дизайн интерфейсов и то, как работают команды и диагностика.

Как работает программа
----------------------

Программа xpic позволяет моделировать физику плазмы методом частиц в ячейках, оставляя при этом возможность гибко настраивать основной вычислительный цикл, т.е. использование *явных*, *полунеявных*, либо полностью *неявных* схем. Программа использует PETSc для вычислений и MPI + OpenMP для параллельной обработки. Структура работы программы выглядит следующим образом:

1. **Инициализация**: Программа начинается в ``src/main.cpp``, загружается конфигурация из JSON файла, создается соответствующая реализация симуляции и происходит её инициализация;

2. **Настройка**: Анализируется конфигурация, описанная в JSON файле, и создаются необходимые команды и диагностики, после чего выполняются команды из раздела ``"Presets"`` для установки начальных условий: магнитных полей, распределения частиц и т.д.;

3. **Основной цикл**: Симуляция выполняется по временным шагам, где:

  - Выполняются команды предустановки шага;

  - Выполняется основной физический шаг симуляции;

  - Запускается диагностика для сбора данных;

4. **Завершение**: Все ресурсы корректно освобождаются.


Организация компонентов по директориям
--------------------------------------

Код организован в следующие основные директории:

**src/interfaces/**: Абстрактные базовые классы, определяющие основные интерфейсы

- ``simulation.h/cpp``: Основной интерфейс симуляции;
- ``particles.h/cpp``: Интерфейс управления частицами;
- ``command.h/cpp``: Интерфейс команд, используемых для модификации вычислительного цикла;
- ``diagnostic.h/cpp``: Интерфейс диагностик, используемых для вывода данных о моделировании;
- ``builder.h/cpp``: Фабрика для создания компонентов.

**src/impls/**: Конкретные реализации симуляций, доступны:

- ``basic/``: Базовая реализация (явная схема): схема Бориса, метод Езиркепова, FDTD;
- ``ecsim/``: Сохраняющая энергию полунеявная схема;
- ``ecsimcorr/``: Сохраняющая энергию *и заряд* схема, расширяющая методы ``ecsim/``;
- ``eccapfim/``: Полностью неявная схема, сохраняющая и энергию, и заряд.

**src/commands/**: Реализации команд и их строители

- Различные типы команд (инжекция частиц, установка полей и т.д.);
- Поддиректория ``builders/``, где лежат конструкторы команд по JSON описанию.

**src/diagnostics/**: Реализации диагностики и их строители

- Различные типы диагностики (просмотр полей, распределения частиц и т.д.);
- Поддиректория ``builders/``, где лежат конструкторы диагностик по JSON описанию.

**src/utils/**: Вспомогательные классы и функции.

**src/algorithms/**: Реализации алгоритмов моделирования.

Ключевые паттерны проектирования
--------------------------------

- **Template Method Pattern**: Шаблон цикла моделирования определен в базовом классе, а реализация одного шага симуляции определяется в виртуальных методах;
- **Factory Pattern**: Используется для создания реализаций симуляции, команд и диагностики на основе конфигурации в JSON файле;
- **Builder Pattern**: Сложные объекты (команды/диагностика) конструируются через строители.


Интерфейсы и выбор реализаций: симуляции, команды и диагностики
---------------------------------------------------------------

Интерфейс описывает какие возможности будут иметь объекты (симуляции, команды, диагностики), а реализации описывают необходимую логику работы, соответствующую интерфейсу.

Интерфейс симуляции
~~~~~~~~~~~~~~~~~~~

- **Базовый класс**: ``interfaces::Simulation`` определяет шаблон цикла моделирования;

- **Выбор**: Функция ``build_simulation()`` в ``simulation.cpp`` выбирает реализации на основе поля ``"Simulation"`` в конфигурационном файле:

  .. code-block:: cpp

    if (simulation_str == "basic")
      simulation = std::make_unique<basic::Simulation>();
    else if (simulation_str == "ecsim")
      simulation = std::make_unique<ecsim::Simulation>();
    // etc.

Интерфейс частиц
~~~~~~~~~~~~~~~~

- **Базовый класс**: ``interfaces::Particles`` предоставляет абстрактный интерфейс частиц;

- **Реализация**: Каждая реализация симуляции имеет свой собственный класс частиц (например, ``ecsim::Particles``), который наследуется от базового интерфейса;

- **Хранение**: Частицы хранятся в 3D сетке и перемещаются между ячейками с учётом MPI.

Интерфейс команд
~~~~~~~~~~~~~~~~

Команды необходимы для описания начальных условий и дополнительных действий помимо основного вычислительного цикла, который реализован для выбранной симуляции.

- **Базовый класс**: ``interfaces::Command`` с виртуальным методом ``execute(timestep)``;

- **Выбор**: Команды создаются функцией ``build_commands()``, которая парсит JSON конфигурацию и создает соответствующие объекты команд, используя паттерн строителя;

- **Выполнение**: В конфигурационном файле есть разделение на

  1. ``"Presets"``: Запускаются один раз во время инициализации для установки начальных условий
  2. ``"StepPresets"``: Запускаются в начале каждого временного шага

- **Хранение**: Команды хранятся в векторах и выполняются последовательно в цикле симуляции;

- **Типы**: Включает ``SetMagneticField``, ``InjectParticles``, ``RemoveParticles`` и т.д.

Интерфейс диагностики
~~~~~~~~~~~~~~~~~~~~~

Диагностики позволяют выводить данные о моделировании, которые затем можно визуализировать с помощью ``python``-скриптов расположенных в папке ``tools/``.

- **Базовый класс**: ``interfaces::Diagnostic`` с виртуальным методом ``diagnose(timestep)``;

- **Выбор**: Диагностики создаются функцией ``build_diagnostics()``, которая создает объекты диагностики на основе конфигурации аналогично тому как создаются команды;

- **Периодическое выполнение**: Диагностика запускается на основе настройки ``diagnose_period``;

- **Вывод**: Результаты сохраняются в указанную выходную директорию;

- **Типы**: Включает ``FieldView``, ``DistributionMoment``, ``VelocityDistribution`` и т.д.
